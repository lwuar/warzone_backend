var path = require('path');
var crypto = require('crypto');
var fs = require('fs')
const defaultConfig = require("../config/default.config.js");
const CurDate = require('./date.helper.js');
var jwt = require('jsonwebtoken');

// public and private key for RSA 2048, key generated by ssh-keygen
const PUBLIC_KEY_RSA = fs.readFileSync(path.resolve("./app/crypto/test.pub"), "utf8");
const PRIVATE_KEY_RSA = fs.readFileSync(path.resolve("./app/crypto/test"), "utf8");

// key for AES_CBC_128
const KEY_AES = fs.readFileSync(path.resolve("./app/crypto/aes.key"), "utf8");
const IV_AES = fs.readFileSync(path.resolve("./app/crypto/aesIV.key"), "utf8");

function encryptRSA(plaintext) {
    if (plaintext == null)
        return null;

    const buffer = Buffer.from(plaintext);
    const encrypted = crypto.publicEncrypt({
        key: PUBLIC_KEY_RSA,
        padding: crypto.constants.RSA_PKCS1_PADDING
    }, buffer);
    return encrypted.toString("base64");
}

function decryptRSA(cipher) {
    if (cipher == null)
        return null;

    const buffer = Buffer.from(cipher, "base64");

    const decrypted = crypto.privateDecrypt({
        key: PRIVATE_KEY_RSA,
        padding: crypto.constants.RSA_PKCS1_PADDING
    }, buffer);

    return decrypted.toString("utf8");
}


// correct password sample abcd1234*
//KtNSf2BCO0N/Ckc3tVHj4j9e+qsOrJTGCJFSX2qXJLJ8OJNihHOboGKdugHoB2ep4kXMPNFrV2Qf54nFM3mm92dwyeSpO2ezQDrySOm32QwFXgjQXUPppgTYGmUK0Msr7dLGrar2JHg9wc4LjswHhkpOt1PHrljuOPPoXz+KAJTj13pGDxR9T7ZrNAo9s8p64WjVYSpCFLr/xC/BJESpZ0rBNP34fDzqNDxBieQZ4OkJXLAZY2R99v2GkeQPrWBmDZBzL/ziARV7hoLdG2tECJmiEzWfRaGq8rB915ZadGdUQYmOwxqOIw0IbMWwyUoAsXpA3RM6K9ytOq+IBHXeFA==

// wrong password helloworld 
//CyhxdcXs/+CtqibUBS4QW6le8AFy+o8nOBeLobQNLWxbV61sCwsOzeAsEkjLXYsQJh5Fhezx1f3ZgjYc0JuOdRKk+drokuoplQ6lQI0Ma85Nh32+6mlx+EcKo9y7OGXVPXsxKzIrgmEkHBAcssAuDPaidrUit7KIl7jD+AkBwNSmrvc6bgi4dr7S6VxcJfSAsQ/EDiL7Y/4TeagPHMiY1qdVBkUoeKkQXZA2MkDVfbqwCmQGfQLim3SD08qd8VzrdxLsOl0tq9JYosFW1k2FloM57uk0Q9iN/AdYzShATCHprXhvatQXYrQxi4T8uD0XUm0NRlXYEtKqz7SrxTfnzA==

function getPasswordHash(str) {
    // TODO confirm with app dev.
    // plaintext = decryptRSA(str);
    plaintext = str;
    // Minimum eight characters, at least one letter, one number and one special character:
    const re = defaultConfig.PASSWORD_REGEX;
    if (re.test(plaintext) == false) {
        // result({ message: "wrong password format" }, null)
        throw "wrong password format";
    }

    salt = crypto.randomBytes(16).toString('hex');
    hash = crypto.pbkdf2Sync(plaintext, salt,
        1000, 64, defaultConfig.HASH_ALGO).toString(`hex`);
    return [hash, salt];

}

function getToken(uid, username, account_level, loginTime) {
    nounce = crypto.randomBytes(16).toString('hex');
    const token = jwt.sign({
        uid: uid,
        username: username,
        account_level: account_level,
        loginTime: loginTime,
        nounce: nounce
    }, "YOUR_SECRET_KEY");
    return [token, nounce];
}

function verifyToken(username, time, nounce, token) {
    if (time - CurDate > 1000 * 3600)
        return false;

    plaintext = username + time;
    newtoken = crypto.pbkdf2Sync(plaintext, nounce,
        1000, 64, defaultConfig.HASH_ALGO).toString(`hex`);
    return newtoken == token;

}

// // password that no one know, no plaintext returned.
// function createPasswordHash() {


//     const length = defaultConfig.PASSWORD_LENGTH;
//     const wishlist = defaultConfig.PASSWORD_WISHLIST;

//     const plaintext = Array.from(crypto.randomFillSync(new Uint32Array(length)))
//         .map((x) => wishlist[x % wishlist.length])
//         .join('')

//     salt = crypto.randomBytes(16).toString('hex');
//     hash = crypto.pbkdf2Sync(plaintext, salt,
//         1000, 64, defaultConfig.HASH_ALGO).toString(`hex`);
//     return [hash, salt];

// }


function encryptAES(plaintext) {
    if (plaintext == null)
        return null;

    let cipher = crypto.createCipheriv(defaultConfig.SYMMETRIC_ALGO, KEY_AES, IV_AES);
    let encrypted = cipher.update(plaintext, 'utf8', 'base64');
    encrypted += cipher.final('base64');
    return encrypted;
}

function decryptAES(cipher) {
    if (cipher == null)
        return null;

    let decipher = crypto.createDecipheriv(defaultConfig.SYMMETRIC_ALGO, KEY_AES, IV_AES);
    let decrypted = decipher.update(cipher, 'base64', 'utf8');
    return (decrypted + decipher.final('utf8'));
}

function verifyPassword(pw_given, pw_hash, salt) {
    // TODO confirm with app dev.
    // plaintext = decryptRSA(pw_given);
    plaintext = pw_given;
    inputHash = crypto.pbkdf2Sync(plaintext, salt,
        1000, 64, defaultConfig.HASH_ALGO).toString(`hex`);

    return inputHash == pw_hash;

}



function generateRandomString(length) {
    return crypto.randomBytes(length).toString('hex')
}

module.exports = {
    encryptRSA,
    decryptRSA,
    getPasswordHash,
    encryptAES,
    decryptAES,
    verifyPassword,
    // createPasswordHash,
    generateRandomString,
    getToken
}